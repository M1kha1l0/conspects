# Работа с памятью
Для каждого процесса ОС выделяет определенный кусок виртуальной памяти, которая связывается с физической памятью с помощью механизмов memorymapping-а.
Такой подход обеспечивает: 
- безопасность программ (чтобы не поубивали друг друга какой-нибудь случайной записью в чужую память).
- виртуальная память представляет собой один непрерывный кусок памяти в то время, как физическая память поделена на куски.

## Разделы виртуализированной памяти процесса
...

## Stack
Статический раздел виртуальной памяти (ограниченный раздел памяти) процесса, где хранятся все созданные статические переменные в коде. Оптимизируется компилятором и ручное взаимодействие со стеком памяти не нужно, система сама очистит неиспользуемые переменные.
Все объекты созданные на куче известны на этапе компиляции.

```c
#include <stdio.h>

int main() {
	int array[10]; // статический массив размера 10
	print("size of array: %d\n", sizeof(array));
	return 0;
}
```
### Стек вызова функций
**Stack frame** - содержит в себе аргументы, результат и вид вызова для рекурсивной функции.
ДОПИСАТЬ ИЗ ПРЕЗЕНТАЦИИ

## Heap
Куча - динамический раздел памяти процесса.  Требует ручного взаимодействия с памятью, т.е. выделять память под переменную и освобождать по окончанию программы. Куча не имеет ограничений по размеру и поэтому может разрастаться по мере необходимости.

### malloc/calloc
**malloc** - функция для выделения памяти для объектов произвольного размера. Запрашивает у ОС раздел памяти равный количеству байт в аргументах.
malloc не гарантирует выделение памяти и в случае ошибки выделения вернет нулевой указатель (NULL). 
malloc возвращает byte-array и требует явного приведения типа к нужному указателю.
`void* malloc(size_t bytes_count);`

**calloc** - функция аналогичная malloc. Принимает на вход размер типа и количество элементов массива с таким типом. Возвращает указатель с заданным типом
`type* calloc(type, size_t bytes_count);`

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
	int size = 10;
	int *array1 = (int*)malloc(size * sizeof(int)); // return void*
	int *array2 = calloc(sizeof(int), size); // return int*
	
	printf("size of array1: %d\n", sizeof(array1)); // 10 bytes
	printf("size of array2: %d\n", sizeof(array2)); // 10 bytes
	return 0;
}
```

### new[]
```cpp
#include <iostream>

int main() {
	int size = 10;
	int *array = new int[size];
	
	std::cout << "size of array: " << sizeof(array) << '\n';
	return 0;
}
```
