---
tags:
  - flask
  - python
  - bd
---
# Начало работы
Для работы с базой данных у flask есть специальная библиотека **flask_sqlalchemy**

app.py:
```python
from flask import Flask, render_template, url_for
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
# в концигурации приложения указываем какую базу данных будем использовать
# для примера возьмем sqlite
# после /// пишем название файла базы данных
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///data.db'
# инициализируем объект базы данных с помощью flask-объекта
db = SQLAlchemy(app)
```

В flask база данных берется из модели класса, который содержит описание столбцов. Такой класс должен наследовать от встроенного объекта базы данных

app.py:
```python
from datetime import datetime

class model(db.Model):
	# тип целочисленный и уникальное значение
	id = db.Column(db.Integer, primary_key=True)
	# здесь необходима строка с максимальной длиной 100 символов
	title = db.Column(db.String(100), nullable=False)
	# специальный тип данных для большого текста
	text = db.Column(db.Text, nullable=False)
	# столбец для указания времени. по умолчанию ставится текущее время на сервере
	date = db.Column(db.DateTime, default=datetime.utcnow)

	def __repr__(self):
		return '<model %r>' % self.id
```

Все столбцы базы данных определяются через db.Column и далее указывается тип данных.
У каждой таблицы обязано быть поле **id** с уникальным значением. За этот параметр отвечает маркер **primary_key**. 
Для некоторых столбцов необходимо какое-то значение. Для этого существует специальный маркер **nullable**, в значении True может быть пустым. Если необходима какая запись, но можно поставить значение по умолчанию при пустом вводе, то маркер **default** поставить необходимое значение, которое передано в аргумент, в поле.

Подробнее о типах и маркерах здесь: [[Типы данных в базе]]

Теперь, чтобы создать нашу таблицу по классу выполним в интерактивном режиме python команду ```with app.app_context(): db.create_all ```

# Запись данных из формы
Если мы хотим принимать какие-то данные из формы на странице, то необходимо создать форму с post-запросом.

add.html:
```html
{% extends 'base.html' %}

{% block title %}
Добавление записи
{% endblock %}

{% block body %}
<div>
	<h1>Добавить запись</h1>
	<form action="/add" method="post">
		<input type="text" name="title" id="title">
		<textarea name="text" id="text"></textarea>
		<input type="submit">
	</form>
</div>
{% endblock %}
```

Для удобства передадим каждому полю формы его идентификатор с названием поля базы данных. Аргумент name будет использоваться в обращении к переменной формы при обработке данных.
В форме указывается аргумент **action**. Он нужен, если обработка формы будет происходить не на данной странице, а на странице с другим адресом. По умолчанию (если не указывать action вообще) обработка проводится на текущей странице.

Далее создаем маршрут с обработкой формы

app.py:
```python
from flask import request, redirect

@app.route('/add', methods=['POST', 'GET'])
def add():
	# проверяем обращение на странице
	if request.method == 'POST':
		title = request.form['title']
		text = request.form['text']
		  
		try:
			# внутри add создаем экземпляр класса база
			db.session.add(model(text=text, title=title))
			# добавляем в базу данных
			db.session.commit()
			# переадресуемся на страницу с записями
			return redirect('/posts')
		except:
			return "Произошла ошибка!'
	else:
		return render_template('add.html')
```

# Вывод данных
Допустим мы хотим попробовать вывести данные из базы.
Создадим специальный адрес и страницу для вывода записей в базе.

app.py:
```python
@app.route('/posts')
def posts():
	data = model.query.all()
	return render_template('posts.html', data=data)
```

В данном случае **data** будет массивом записей класса **model**, который был создан для хранения данных.

Обращение к базе данных происходит по методу **query**  и далее следует выбор, что именно мы хотим взять. Метод ```all()``` вернет массив со всеми записями, метод ```first()``` - первый элемент, метод ```get()``` конкретный элемент по id в базе. Для того чтобы брать массивы данных по аргументу, существует метод ```order_by()```, но подробнее о работе с запросами здесь: [[Запросы к базе данных]]

Теперь разберем возвращаемое значение. ```render_template``` принимает неограниченное количество аргументов, которые могут отображаться на странице, в данном случае мы назовем передаваемые данные **data**, как и массив запроса от базы данных, чтобы не возникало путаницы.

Теперь создадим страницу, на которой будут отображаться записи из базы данных, а также обработаем вариант, когда записей нет.

posts.html:
```html
{% extends 'base.html' %}

{% block title %}
Просмотр постов
{% endblock %}

{% block body %}
	<div>
		<h1>Все записи</h1>
		{% if data|length > 0 %}
			{% for el in data %}
			<div>
				<h1>{{ el.title }}</h1>
				<p><b>{{ el.date.date() }}</b></p>
				<a href="/posts/{{ el.id }}">Подробнее</a>
			</div>
			{% endfor %}
		{% else %}
			<p>Записи не найдены</p>
		{% endif %}
	</div>
{% endblock %}
```

В данном случае мы передаем все записи в базе, так что используем цикл шаблонизатора **jinja2**, подробнее о работе с ним здесь: [[Шаблоны страниц]]

Таким образом мы вывели на страницу все записи в базе данных в контейнерах, в которых содержится название записи, а также время публикации.

Теперь мы хотим посмотреть содержимое записи. Чтобы это сделать создадим специальную ссылку, которая ведет к маршруту отображения конкретной записи. В данном случае **/posts/<int:id>**. Будем ориентироваться по id каждой записи.

Создадим маршрут

app.py:
```python
@app.route('/posts/<int:id>')
def view_post(id):
	# post = model.query.get(id)
	post = model.query.get_or_404(id)
	return render_template('view_post.html', post=post)
```

В маршруте обязательно указываем в аргументе id записи, чтобы достать нужный из базы данных используя функцию ```get()``` и передаем данные на страницу. При работе с базами данных, при получении элемента таблицы, лучше использовать ```get_or_404()``` вместо ```get()```.

Создадим страницу для просмотра конкретной записи.

view_post.html:
```html
{% extends 'base.html' %}

{% block title %}
Просмотр записи №{{ post.id }}
{% endblock %}

{% block body %}
	<div>
		<h1>{{ post.title }}</h1>
		<p>{{ post.text }}</p>
		<p><b>{{ post.date.date() }}</b></p>
	</div>
{% endblock %}
```

Здесь логика построения та же, что и у предыдущей страницы.

# Удаление и обновление запись
Для удаления и редактирования записей необходимо добавить 2 маршрута с привязкой к индексу записи в базе данных.

app.py:
```python
@app.route('/posts/<int:id>/delete')
def post_delete(id):
	# получаем запись 
	post = model.query.get_or_404(id)
	
	try:
		# удаляем объект из базы
		db.session.delete(post)
		db.session.commit()
		# возвращаемся к всем записям
		return redirect('/posts')
	except:
		return "Внутренняя ошибка"  
  

@app.route('/posts/<int:id>/update', methods=['POST', 'GET'])
def post_update(id):
	# Получаем объект, который хотим поменять
	post = model.query.get(id)
	# меняем, если требуется, без создания нового объекта
	if request.method == 'POST':
		post.title = request.form['title']
		post.text = request.form['text']
		
		try:
			# записываем изменения
			db.session.commit()
			return redirect('/posts')
		except:
			return "Внутренняя ошибка"
	else:
		# важно передать объект на страницу, чтобы было видно, что редактировать
		return render_template('post_update.html', post=post)
```

Добавим соответствующие ссылки на странице просмотра записи.

post_view.html:
```html
{% extends 'base.html' %}

{% block title %}
Просмотр записи №{{ post.id }}
{% endblock %}

{% block body %}
<div>
	<h1>{{ post.title }}</h1>
	<p>{{ post.text }}</p>
	<p><b>{{ post.date.date() }}</b></p>
</div>
<div>
	<a href="/posts/{{ post.id }}/delete">Удалить</a>
	<a href="/posts/{{ post.id }}/update">Редактировать</a>
</div>
{% endblock %}
```

Теперь создадим страницу редактирования с отображением текущих данных в записи.

post_update.html:
```html
{% extends 'base.html' %}

{% block title %}
Обновите информацию
{% endblock %}

{% block body %}
<div>
	<h1>Редактировать запись №{{ post.id}}</h1>
	<form method="post">
		<input type="text" name="title" id="title" value="{{ post.title }}">
		<textarea name="text" id="text">{{ post.text }}</textarea>
		<input type="submit">
	</form>
</div>
{% endblock %}
```