---
tags:
  - flask
  - python
---
# Загрузка страниц из файла
По умолчанию все шаблоны страниц Flask ищет в специальной директории проекта: **templates** 
Структура простого проекта:
```
site/
	templates/
		index.html
	app.py
```

Для того чтобы загружать страницы необходимо в эндпоинте нужного маршрута прописать специальную функцию ```render_template()```

app.py:
```python
from flask import Flask, render_template
app = Flask(__name__)

@app.route('/')
def index():
	return render_template('index.html')


if __name__ == "__main__":
	app.run(debug=True)
```

templates/index.html:
```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>main page</title>
</head>
<body>
	<h1>Hello, World</h1>
</body>
</html>
```

# Загрузка стилей из файлов
Для загрузки необходимо использовать шаблонизатор и специальную директорию для flask.

```
site/
	static/
		css/
			main.css
	templates/
		base.html
		index.html
		about.html
	app.py
```

Для добавление стилей, js-кода и прочего для flask-а необходимо добавить директорию **static**. И теперь, если хотим загрузить необходимый стиль, то прописываем в head страницы:

```html
<link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">
```

В href-e прописывается специальная функция шаблонизатора url_for. В ней необходимо первым аргументом указать в какой директории работаем и следующим аргументом путь до файла.
НО важно в файле запуска прописать импорт данной функции:

```python
from flask import url_for
```


# Синтаксис jinja2
Для передачи любых переменных в jinja2 используются двойные фигурные скобки. Если на страницу передается переменная **data**, то ее вывод на странице будет такой:

```html
{{ data }}
```

Если **data** какой-то класс данных, то поскольку шаблонизатор связан с flask последующие манипуляции с переменным внутренними методами класса будут такими же, как и в python.

Другое дело, когда необходимо выводить массивы данных. Шаблонизатор предоставляет такую возможность и опять же весь синтаксис схож с python-овским.
Пусть есть массив **Data**, тогда перебор его элементов выглядит так:

```html
{% for element in Data %}
	<div>
		<h1>{{ element }}</h1>
	</div>
{% endfor %}
```

Важное замечание: в jinja2 можно создавать много блоков-шаблонов и **for** тоже таковым является, поэтому у каждого цикла должно быть завершение ```{% endfor %}```. А также все что касается большого вывода или блоков-шаблонов обозначается через фигурные скобки с знака процента.
# Шаблоны страниц
При большом количестве страниц с некоторым одинаковом содержимым будет удобно создать шаблон, по которому будет строиться все. Flask предоставляет такую возможность с помощью шаблонизатора jinja2. Для этого необходимо создать специальный файл-шаблон. Например base.html (название может быть любым):

base.html:
```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>{% block title %}{% endblock %}</title>
</head>
<body>
	{% block body %}{% endblock %}
</body>
</html>
```

На данном этапе страницы отличаются только в названии и содержимом. Создадим соответствующие блоки для шаблонов страниц. Как видим в начале необходимо прописать ``` {% block name %}```. Здесь block - синтаксическая конструкция для обозначения вставки какого-то контента. За ним следует название данного блока и завершение ```{% endbblock %}```.

Теперь перепишем главную страницу

index.html:
```html
{% extends 'base.html' %}

{% block title %}
Главная страница
{% endblock %}

{% block body %}
<h1>Hello, World!</h1>
{% endblock %}
```

Здесь **extends** - указывает flask-у какой файл взять за шаблон, а далее необходимо передать путь к шаблону в директории templates. Далее идут блоки с необходимым содержимым на странице.
Теперь аналогично выглядит страница с информацией о сайте

about.html:
```html
{% extends 'base.html' %}

{% block title %}
О нас
{% endblock %}

{% block body %}
<h1>Сайт</h1>
{% endblock %}
```

Шаблонов и наследующих страниц может быть неограниченное количество.
