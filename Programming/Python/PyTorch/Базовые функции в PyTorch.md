---
tags:
  - python
  - ai
  - torch
---
## Tensor

Это ***тип данных*** представляющий из себя многомерный массив

**Ранги тензоров <=> размерность тензора**

> С математической точки зрения тензоры можно рассматривать как обобщение скаля­ров, векторов, матриц и т.п.

Поскольку это обобщение математических объектов, то данный класс имеет все операции взаимодействия (умножение, сложение и т.д.).

### Примеры создания тензоров

Основные функции:
-  `torch.tensor()` - принимает на вход стандартный массив python.
-  `torch.from_numpy()` - принимает на вход `np.array`.
-  `torch.zeros()` - создает тензор введенной размерности заполненный **0**.
-  `torch.ones()` - создает тензор заданной размерности заполненный **1**.
-  `torch.rand()` - создает тензор заполненный случайными значениями, есть множество похожих функций для случайного заполнения.
-  `torch.arange()` - возвращает список скаляров-тензоров с перебранными значениями, как в `for`

Простой ввод-вывод:
```python
import torch as pyt
import numpy as np

x = [[1, 2], [3, 4]]
y = np.array([[1, 2], [2, 1]], dtype=np.int32)

matrixX = pyt.tensor(x)
matrixY = pyt.from_numpy(y)

print(matrixX)
print(matrixY)
```

Вывод:
```python
tensor([[1, 2],
        [3, 4]])
tensor([[1, 2],
        [2, 1]], dtype=torch.int32)
```

Создание единичного и случайно заполненного тензора:
```python
import torch as pyt
import numpy as np

# указывается размерность
matrixX = pyt.ones(3, 3)
# указывается размерность
matrixY = pyt.rand(2, 3)
# сначала диапазон, а потом размерность tuple
matrixZ = pyt.randint(1, 10, (2, 3))

print(matrixX)
print(matrixY)
print(matrixZ)
```

Вывод:
```python
tensor([[1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.]])
tensor([[0.7829, 0.0140, 0.1280],
        [0.4953, 0.8900, 0.6931]])
tensor([[8, 4, 6],
        [7, 4, 2]])
```

Массив тензоров:
```python
import torch as pyt

t = pyt.arange(6, dtype=pyt.float32)
for i in t:
	print(i)
```

Вывод:
```python
tensor([О.])
tensor([1.])
tensor([2.])
tensor([3.])
tensor([4.])
tensor([5.])
```

### Управление типами и формой тензора

Основные функции:
-  `torch.to()` - меняет типы всех значений в тензоре на введенный.
-  `torch.transpose()` - принимает на вход тензор и возвращает транспонированную копию
-  `torch.reshape()` - принимает на вход тензор и возвращает копию с измененным размером, если это возможно. Может повысить размерность.
-  `torch.squeeze()` - принимает на вход тензор и возвращает копию с пониженной размерностью (удаляет ненужные измерения размерностью ==**1**==). 

Пример изменения типов в тензоре:
```python
import torch as pyt

t = pyt.tensor([1, 2, 3, 4], dtype=pyt.int32)
t_new = t.to(pyt.float32)

print(t.dtype, ' --> ', t_new.dtype)
```

Вывод:
```python
torch.int32  -->  torch.float32
```

Примеры изменения формы тензора:
```python
import torch as pyt

print('"torch.transpose()" example:')
t = pyt.rand(3, 5)
t_new = pyt.transpose(t, 0, 1)
print(t.shape, ' --> ', t_new.shape)

print('\n"torch.reshape()" example:')
t = pyt.zeros(30)
t_new = t.reshape(5, 6)
print(t_new.shape)

print('\n"torch.squeeze()" example:')
t = pyt.zeros(1, 2, 1, 4, 1)
t_new = pyt.squeeze(t, 2)
print(t.shape, ' --> ', t_new.shape)
```

Вывод:
```python
"torch.transpose()" example:
torch.Size([3, 5])  -->  torch.Size([5, 3])

"torch.reshape()" example:
torch.Size([5, 6])

"torch.squeeze()" example:
torch.Size([1, 2, 1, 4, 1])  -->  torch.Size([1, 2, 4, 1])
```

###  (!)Применение математических операций

Основные функции:
-  `torch.multiply()` - две матрицы одинакового размера, возвращает матрицу с поэлементным умножением.
-  `torch.mean()` - вернет осевое среднее значение, имеет аргумент `axis`. Схожа с `torch.sum()` - сумма по осям;  и `torch.std()` - стандартное отклонение.
-  `torch.matmult()` - стандартное умножение матриц.
-  `torch.linalg.norm()` - вычисление $L^{p}$-нормы тензора
###### Что такое $L^{p}$-норма?
https://ru.wikipedia.org/wiki/%D0%9D%D0%BE%D1%80%D0%BC%D0%B0_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)
### (!)Сплитование, стекирование и конкатенация

Основные функции:
-  `torch.chunk()` - принимает на вход тензор, который разделяет на равные тензоры заданным целым числом, либо делит на заданный список размеров тензора через аргумент `split_size_of_sections`.
-  `torch.stack()` - складывает "штабелем" тензоры одинакового размера, регулируется аргументом `axis`.
-  `torch.cat()` - возвращает объединенный тензор из двух одинаковых размерностей, но разных по размеру.

## DataLoader

Здесь рассматривается использование объектов `DataLoader` и `Dataset`.
`DataLoader` это фреймворк для организации конвейера данных для предварительной обработки.

**СТР 374**
